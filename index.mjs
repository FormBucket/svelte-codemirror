function run(fn) {
    return fn();
}
function blank_object() {
    return Object.create(null);
}
function run_all(fns) {
    fns.forEach(run);
}
function custom_event(type, detail) {
    const e = document.createEvent('CustomEvent');
    e.initCustomEvent(type, false, false, detail);
    return e;
}

let current_component;
function set_current_component(component) {
    current_component = component;
}
function get_current_component() {
    if (!current_component)
        throw new Error(`Function called outside component initialization`);
    return current_component;
}
function onMount(fn) {
    get_current_component().$$.on_mount.push(fn);
}
function createEventDispatcher() {
    const component = get_current_component();
    return (type, detail) => {
        const callbacks = component.$$.callbacks[type];
        if (callbacks) {
            // TODO are there situations where events could be dispatched
            // in a server (non-DOM) environment?
            const event = custom_event(type, detail);
            callbacks.slice().forEach(fn => {
                fn.call(component, event);
            });
        }
    };
}
const escaped = {
    '"': '&quot;',
    "'": '&#39;',
    '&': '&amp;',
    '<': '&lt;',
    '>': '&gt;'
};
function escape(html) {
    return String(html).replace(/["'&<>]/g, match => escaped[match]);
}
let on_destroy;
function create_ssr_component(fn) {
    function $$render(result, props, bindings, slots) {
        const parent_component = current_component;
        const $$ = {
            on_destroy,
            context: new Map(parent_component ? parent_component.$$.context : []),
            // these will be immediately discarded
            on_mount: [],
            before_update: [],
            after_update: [],
            callbacks: blank_object()
        };
        set_current_component({ $$ });
        const html = fn(result, props, bindings, slots);
        set_current_component(parent_component);
        return html;
    }
    return {
        render: (props = {}, options = {}) => {
            on_destroy = [];
            const result = { title: '', head: '', css: new Set() };
            const html = $$render(result, props, {}, options);
            run_all(on_destroy);
            return {
                html,
                css: {
                    code: Array.from(result.css).map(css => css.code).join('\n'),
                    map: null // TODO
                },
                head: result.title + result.head
            };
        },
        $$render
    };
}
function add_attribute(name, value, boolean) {
    if (value == null || (boolean && !value))
        return '';
    return ` ${name}${value === true ? '' : `=${typeof value === 'string' ? JSON.stringify(escape(value)) : `"${value}"`}`}`;
}

/* src/CodeMirror.svelte generated by Svelte v3.23.2 */
const is_browser = typeof window !== "undefined";
let codemirror_promise;
let _CodeMirror;

if (is_browser) {
	codemirror_promise = import('codemirror');

	codemirror_promise.then(mod => {
		_CodeMirror = mod.default;
	});
}

function sleep(ms) {
	return new Promise(fulfil => setTimeout(fulfil, ms));
}

const CodeMirror_1 = create_ssr_component(($$result, $$props, $$bindings, $$slots) => {
	const dispatch = createEventDispatcher();
	let { value = "" } = $$props;
	let { readonly = false } = $$props;
	let { errorLoc = null } = $$props;
	let { lineNumbers = true } = $$props;
	let { tab = true } = $$props;
	let { cmdEnter = null } = $$props;
	let { ctrlEnter = null } = $$props;
	let { shiftEnter = null } = $$props;
	let { cmdPeriod = null } = $$props;
	let { ctrlPeriod = null } = $$props;
	let { cmdHiffen = null } = $$props;
	let { ctrlHiffen = null } = $$props;
	let { cmdEqual = null } = $$props;
	let { ctrlEqual = null } = $$props;
	let { cmdOpenSquareBracket = null } = $$props;
	let { ctrlOpenSquareBracket = null } = $$props;
	let { cmdCloseSquareBracket = null } = $$props;
	let { ctrlCloseSquareBracket = null } = $$props;
	let { cmdForwardSlash = null } = $$props;
	let { ctrlForwardSlash = null } = $$props;

	async function set(new_value, new_mode, new_theme) {
		if (new_mode !== mode || new_theme !== theme) {
			await createEditor(mode = new_mode, theme = new_theme);
		}

		value = new_value;
		updating_externally = true;
		if (editor) editor.setValue(value);
		updating_externally = false;
	}

	function update(new_value) {
		value = new_value;

		if (editor) {
			const { left, top } = editor.getScrollInfo();
			editor.setValue(value = new_value);
			editor.scrollTo(left, top);
		}
	}

	function getValue() {
		if (editor) {
			return editor.getValue();
		}
	}

	function getLine(lineIndex) {
		if (editor) {
			return editor.getLine(lineIndex);
		}
	}

	function getSelection() {
		if (editor) {
			let expression = editor.getSelection();

			if (expression == "") {
				let cursorInfo = editor.getCursor();
				expression = editor.getDoc().getLine(cursorInfo.line);
			}

			return expression;
		}
	}

	function getCursorPosition() {
		return editor ? editor.getCursor() : undefined;
	}

	function getRange(from, to) {
		return editor ? editor.getRange(from, to) : undefined;
	}

	function commentSelection() {
		if (editor) {
			let expression = editor.getSelection();

			if (expression == "") {
				let cursorInfo = editor.getCursor();
				expression = editor.getDoc().getLine(cursorInfo.line);
			}

			return expression;
		}
	}

	function getBlock() {
		if (editor) {
			let cursorInfo = editor.getCursor();

			//find post divider
			let line = cursorInfo.line;

			let linePost = editor.lastLine();

			while (line < linePost) {
				if ((/___+/).test(editor.getLine(line))) {
					// Test RegEx at least 3 underscores
					linePost = line - 1;

					break;
				}

				line++;
			}

			line = cursorInfo.line;
			let linePre = -1;

			while (line >= 0) {
				// console.log(editor2.getLine(line));
				if ((/___+/).test(editor.getLine(line))) {
					linePre = line;
					break;
				}

				line--;
			}

			if (linePre > -1) {
				linePre++;
			}

			let code = editor.getRange({ line: linePre, ch: 0 }, { line: linePost + 1, ch: 0 });
			return code;
		}
	}

	function resize() {
		editor.refresh();
	}

	function focus() {
		editor.focus();
	}

	let w;
	let h;
	let mode;
	let theme;

	const modes = {
		js: { name: "javascript", json: false },
		json: { name: "javascript", json: true },
		ebnf: { name: "ebnf", base: "text/html" },
		svelte: { name: "handlebars", base: "text/html" },
		closure: { name: "clojure", base: "text/x-clojure" },
		asn: { name: "asn.1", base: "text/x-ttcn-asn" },
		sema: { name: "sema", base: "text/html" }
	};

	const refs = {};
	let editor;
	let updating_externally = false;
	let marker;
	let error_line;
	let destroyed = false;
	let CodeMirror;
	let previous_error_line;

	onMount(() => {
		if (_CodeMirror) {
			CodeMirror = _CodeMirror;

			createEditor(mode || "svelte", theme).then(() => {
				if (editor) editor.setValue(value || "");
			});
		} else {
			codemirror_promise.then(async mod => {
				CodeMirror = mod.default;
				await createEditor(mode || "svelte", theme);
				if (editor) editor.setValue(value || "");
			});
		}

		return () => {
			destroyed = true;
			if (editor) editor.toTextArea();
		};
	});

	let first = true;

	async function createEditor(mode, theme) {
		if (destroyed || !CodeMirror) return;
		if (editor) editor.toTextArea();

		// console.log("createEditor:", theme);
		const opts = {
			lineNumbers,
			lineWrapping: true,
			indentWithTabs: true,
			indentUnit: 2,
			tabSize: 2,
			value: "",
			mode: modes[mode] || { name: mode },
			readOnly: readonly,
			autoCloseBrackets: true,
			autoCloseTags: true,
			extraKeys: {}
		};

		if (theme !== undefined) opts.theme = theme;
		if (!tab) opts.extraKeys = { Tab: tab, "Shift-Tab": tab };
		if (cmdEnter) opts.extraKeys["Cmd-Enter"] = cmdEnter;
		if (ctrlEnter) opts.extraKeys["Ctrl-Enter"] = ctrlEnter;
		if (shiftEnter) opts.extraKeys["Shift-Enter"] = shiftEnter;
		if (cmdPeriod) opts.extraKeys["Cmd-."] = cmdPeriod;
		if (ctrlPeriod) opts.extraKeys["Ctrl-."] = ctrlPeriod;
		if (cmdHiffen) opts.extraKeys["Cmd--"] = cmdHiffen;
		if (ctrlHiffen) opts.extraKeys["Ctrl--"] = ctrlHiffen;
		if (cmdEqual) opts.extraKeys["Cmd-="] = cmdEqual;
		if (ctrlEqual) opts.extraKeys["Cmd-="] = ctrlEqual;
		if (cmdCloseSquareBracket) opts.extraKeys["Cmd-]"] = cmdCloseSquareBracket;
		if (cmdOpenSquareBracket) opts.extraKeys["Cmd-["] = cmdOpenSquareBracket;
		if (ctrlCloseSquareBracket) opts.extraKeys["Ctrl-]"] = ctrlCloseSquareBracket;
		if (ctrlOpenSquareBracket) opts.extraKeys["Ctrl-["] = ctrlOpenSquareBracket;
		if (cmdForwardSlash) opts.extraKeys["Cmd-/"] = () => editor.execCommand("toggleComment");
		if (ctrlForwardSlash) opts.extraKeys["Ctrl-/"] = () => editor.execCommand("toggleComment");

		// if(ctrlForwardSlash)
		//   opts.extraKeys["Ctrl-/"] = (ctrlForwardSlash);
		// if(cmdEnter && !opts.extraKeys["Cmd-Enter"])
		//   opts.extraKeys["Cmd-Enter"] = (cmdEnter);
		// Creating a text editor is a lot of work, so we yield
		// the main thread for a moment. This helps reduce jank
		if (first) await sleep(50);

		if (destroyed) return;
		editor = CodeMirror.fromTextArea(refs.editor, opts);

		editor.on("change", (instance, changeObj) => {
			if (!updating_externally) {
				// const value = instance.getValue();
				dispatch("change", { changeObj });
			}
		});

		editor.on("focus", (instance, event) => {
			if (!updating_externally) {
				dispatch("focus", { event });
			}
		});

		editor.on("blur", (instance, event) => {
			if (!updating_externally) {
				dispatch("blur", { event });
			}
		});

		editor.on("refresh", (instance, event) => {
			if (!updating_externally) {
				dispatch("refresh", { event });
			}
		});

		editor.on("gutterClick", (instance, line, gutter, clickEvent) => {
			if (!updating_externally) {
				dispatch("gutterClick", { line, gutter, clickEvent });
			}
		});

		editor.on("viewportChange", (instance, from, to) => {
			if (!updating_externally) {
				dispatch("viewportChange", { from, to });
			}
		});

		if (first) await sleep(50);
		editor.refresh();
		first = false;
	}

	if ($$props.value === void 0 && $$bindings.value && value !== void 0) $$bindings.value(value);
	if ($$props.readonly === void 0 && $$bindings.readonly && readonly !== void 0) $$bindings.readonly(readonly);
	if ($$props.errorLoc === void 0 && $$bindings.errorLoc && errorLoc !== void 0) $$bindings.errorLoc(errorLoc);
	if ($$props.lineNumbers === void 0 && $$bindings.lineNumbers && lineNumbers !== void 0) $$bindings.lineNumbers(lineNumbers);
	if ($$props.tab === void 0 && $$bindings.tab && tab !== void 0) $$bindings.tab(tab);
	if ($$props.cmdEnter === void 0 && $$bindings.cmdEnter && cmdEnter !== void 0) $$bindings.cmdEnter(cmdEnter);
	if ($$props.ctrlEnter === void 0 && $$bindings.ctrlEnter && ctrlEnter !== void 0) $$bindings.ctrlEnter(ctrlEnter);
	if ($$props.shiftEnter === void 0 && $$bindings.shiftEnter && shiftEnter !== void 0) $$bindings.shiftEnter(shiftEnter);
	if ($$props.cmdPeriod === void 0 && $$bindings.cmdPeriod && cmdPeriod !== void 0) $$bindings.cmdPeriod(cmdPeriod);
	if ($$props.ctrlPeriod === void 0 && $$bindings.ctrlPeriod && ctrlPeriod !== void 0) $$bindings.ctrlPeriod(ctrlPeriod);
	if ($$props.cmdHiffen === void 0 && $$bindings.cmdHiffen && cmdHiffen !== void 0) $$bindings.cmdHiffen(cmdHiffen);
	if ($$props.ctrlHiffen === void 0 && $$bindings.ctrlHiffen && ctrlHiffen !== void 0) $$bindings.ctrlHiffen(ctrlHiffen);
	if ($$props.cmdEqual === void 0 && $$bindings.cmdEqual && cmdEqual !== void 0) $$bindings.cmdEqual(cmdEqual);
	if ($$props.ctrlEqual === void 0 && $$bindings.ctrlEqual && ctrlEqual !== void 0) $$bindings.ctrlEqual(ctrlEqual);
	if ($$props.cmdOpenSquareBracket === void 0 && $$bindings.cmdOpenSquareBracket && cmdOpenSquareBracket !== void 0) $$bindings.cmdOpenSquareBracket(cmdOpenSquareBracket);
	if ($$props.ctrlOpenSquareBracket === void 0 && $$bindings.ctrlOpenSquareBracket && ctrlOpenSquareBracket !== void 0) $$bindings.ctrlOpenSquareBracket(ctrlOpenSquareBracket);
	if ($$props.cmdCloseSquareBracket === void 0 && $$bindings.cmdCloseSquareBracket && cmdCloseSquareBracket !== void 0) $$bindings.cmdCloseSquareBracket(cmdCloseSquareBracket);
	if ($$props.ctrlCloseSquareBracket === void 0 && $$bindings.ctrlCloseSquareBracket && ctrlCloseSquareBracket !== void 0) $$bindings.ctrlCloseSquareBracket(ctrlCloseSquareBracket);
	if ($$props.cmdForwardSlash === void 0 && $$bindings.cmdForwardSlash && cmdForwardSlash !== void 0) $$bindings.cmdForwardSlash(cmdForwardSlash);
	if ($$props.ctrlForwardSlash === void 0 && $$bindings.ctrlForwardSlash && ctrlForwardSlash !== void 0) $$bindings.ctrlForwardSlash(ctrlForwardSlash);
	if ($$props.set === void 0 && $$bindings.set && set !== void 0) $$bindings.set(set);
	if ($$props.update === void 0 && $$bindings.update && update !== void 0) $$bindings.update(update);
	if ($$props.getValue === void 0 && $$bindings.getValue && getValue !== void 0) $$bindings.getValue(getValue);
	if ($$props.getLine === void 0 && $$bindings.getLine && getLine !== void 0) $$bindings.getLine(getLine);
	if ($$props.getSelection === void 0 && $$bindings.getSelection && getSelection !== void 0) $$bindings.getSelection(getSelection);
	if ($$props.getCursorPosition === void 0 && $$bindings.getCursorPosition && getCursorPosition !== void 0) $$bindings.getCursorPosition(getCursorPosition);
	if ($$props.getRange === void 0 && $$bindings.getRange && getRange !== void 0) $$bindings.getRange(getRange);
	if ($$props.commentSelection === void 0 && $$bindings.commentSelection && commentSelection !== void 0) $$bindings.commentSelection(commentSelection);
	if ($$props.getBlock === void 0 && $$bindings.getBlock && getBlock !== void 0) $$bindings.getBlock(getBlock);
	if ($$props.resize === void 0 && $$bindings.resize && resize !== void 0) $$bindings.resize(resize);
	if ($$props.focus === void 0 && $$bindings.focus && focus !== void 0) $$bindings.focus(focus);

	 {
		if (editor && w && h) {
			editor.refresh();
		}
	}

	 {
		{
			if (marker) marker.clear();

			if (errorLoc) {
				const line = errorLoc.line - 1;
				const ch = errorLoc.column;
				marker = editor.markText({ line, ch }, { line, ch: ch + 1 }, { className: "error-loc" });
				error_line = line;
			} else {
				error_line = null;
			}
		}
	}

	 {
		if (editor) {
			if (previous_error_line != null) {
				editor.removeLineClass(previous_error_line, "wrap", "error-line");
			}

			if (error_line && error_line !== previous_error_line) {
				editor.addLineClass(error_line, "wrap", "error-line");
				previous_error_line = error_line;
			}
		}
	}

	return `<textarea tabindex="${"0"}" readonly${add_attribute("this", refs.editor, 1)}>${escape(value)}</textarea>
${!CodeMirror ? `<pre>${escape(value)}</pre>` : ``}`;
});

export default CodeMirror_1;
//# sourceMappingURL=index.mjs.map
